var searchIndex={};
searchIndex["float_cmp"] = {"doc":"float-cmp","i":[[3,"F32Margin","float_cmp","This type defines a margin within two `f32` values might…",null,null],[12,"epsilon","","",0,null],[12,"ulps","","",0,null],[3,"F64Margin","","This type defines a margin within two `f64` values might…",null,null],[12,"epsilon","","",1,null],[12,"ulps","","",1,null],[11,"zero","","",0,[[],["f32margin"]]],[11,"epsilon","","",0,[[["f32"]],["self"]]],[11,"ulps","","",0,[[["i32"]],["self"]]],[11,"zero","","",1,[[],["f64margin"]]],[11,"epsilon","","",1,[[["f64"]],["self"]]],[11,"ulps","","",1,[[["i64"]],["self"]]],[8,"Ulps","","",null,null],[16,"U","","",2,null],[10,"ulps","","The number of representable values or ULPs (Units of Least…",2,[[["self"]]]],[10,"next","","The next representable number above this one",2,[[["self"]],["self"]]],[10,"prev","","The previous representable number below this one",2,[[["self"]],["self"]]],[8,"ApproxEqUlps","","ApproxEqUlps is a trait for approximate equality…",null,null],[16,"Flt","","",3,null],[10,"approx_eq_ulps","","This method tests for `self` and `other` values to be…",3,[[["self"]],["bool"]]],[11,"approx_ne_ulps","","This method tests for `self` and `other` values to be not…",3,[[["self"]],["bool"]]],[8,"ApproxEq","","A trait for approximate equality comparisons.",null,null],[16,"Margin","","This type type defines a margin within which two values…",4,null],[10,"approx_eq","","This method tests that the `self` and `other` values are…",4,[[["into"]],["bool"]]],[11,"approx_ne","","This method tests that the `self` and `other` values are…",4,[[["into"]],["bool"]]],[8,"ApproxEqRatio","","ApproxEqRatio is a trait for approximate equality…",null,null],[11,"approx_eq_ratio","","This method tests if `self` and `other` are nearly equal…",5,[[["self"]],["bool"]]],[11,"approx_ne_ratio","","This method tests if `self` and `other` are not nearly…",5,[[["self"]],["bool"]]],[14,"approx_eq","","",null,null],[11,"from","","",0,[[["t"]],["t"]]],[11,"into","","",0,[[],["u"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,[[["self"],["t"]]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"type_id","","",0,[[["self"]],["typeid"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"into","","",1,[[],["u"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,[[["self"],["t"]]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"type_id","","",1,[[["self"]],["typeid"]]],[11,"from","","",0,[[],["f32margin"]]],[11,"from","","",1,[[],["f64margin"]]],[11,"clone","","",0,[[["self"]],["f32margin"]]],[11,"clone","","",1,[[["self"]],["f64margin"]]],[11,"default","","",0,[[],["f32margin"]]],[11,"default","","",1,[[],["f64margin"]]],[11,"fmt","","",0,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",1,[[["formatter"],["self"]],["result"]]],[11,"approx_ne_ulps","","This method tests for `self` and `other` values to be not…",3,[[["self"]],["bool"]]],[11,"approx_ne","","This method tests that the `self` and `other` values are…",4,[[["into"]],["bool"]]],[11,"approx_eq_ratio","","This method tests if `self` and `other` are nearly equal…",5,[[["self"]],["bool"]]],[11,"approx_ne_ratio","","This method tests if `self` and `other` are not nearly…",5,[[["self"]],["bool"]]]],"p":[[3,"F32Margin"],[3,"F64Margin"],[8,"Ulps"],[8,"ApproxEqUlps"],[8,"ApproxEq"],[8,"ApproxEqRatio"]]};
searchIndex["num_traits"] = {"doc":"Numeric traits for generic mathematics","i":[[3,"ParseFloatError","num_traits","",null,null],[12,"kind","","",0,null],[4,"FloatErrorKind","","",null,null],[13,"Empty","","",1,null],[13,"Invalid","","",1,null],[5,"clamp","","A value bounded by a minimum and a maximum",null,[[["partialord"]],["partialord"]]],[0,"bounds","","",null,null],[8,"Bounded","num_traits::bounds","Numbers which have upper and lower bounds",null,null],[10,"min_value","","returns the smallest finite number this type can represent",2,[[],["self"]]],[10,"max_value","","returns the largest finite number this type can represent",2,[[],["self"]]],[0,"cast","num_traits","",null,null],[5,"cast","num_traits::cast","Cast from one machine scalar to another.",null,[[["numcast"]],[["numcast"],["option"]]]],[8,"ToPrimitive","","A generic trait for converting a value to a number.",null,null],[11,"to_isize","","Converts the value of `self` to an `isize`.",3,[[["self"]],[["isize"],["option",["isize"]]]]],[11,"to_i8","","Converts the value of `self` to an `i8`.",3,[[["self"]],[["option",["i8"]],["i8"]]]],[11,"to_i16","","Converts the value of `self` to an `i16`.",3,[[["self"]],[["i16"],["option",["i16"]]]]],[11,"to_i32","","Converts the value of `self` to an `i32`.",3,[[["self"]],[["option",["i32"]],["i32"]]]],[10,"to_i64","","Converts the value of `self` to an `i64`.",3,[[["self"]],[["i64"],["option",["i64"]]]]],[11,"to_i128","","Converts the value of `self` to an `i128`.",3,[[["self"]],[["i128"],["option",["i128"]]]]],[11,"to_usize","","Converts the value of `self` to a `usize`.",3,[[["self"]],[["usize"],["option",["usize"]]]]],[11,"to_u8","","Converts the value of `self` to an `u8`.",3,[[["self"]],[["option",["u8"]],["u8"]]]],[11,"to_u16","","Converts the value of `self` to an `u16`.",3,[[["self"]],[["u16"],["option",["u16"]]]]],[11,"to_u32","","Converts the value of `self` to an `u32`.",3,[[["self"]],[["u32"],["option",["u32"]]]]],[10,"to_u64","","Converts the value of `self` to an `u64`.",3,[[["self"]],[["u64"],["option",["u64"]]]]],[11,"to_u128","","Converts the value of `self` to an `u128`.",3,[[["self"]],[["option",["u128"]],["u128"]]]],[11,"to_f32","","Converts the value of `self` to an `f32`.",3,[[["self"]],[["f32"],["option",["f32"]]]]],[11,"to_f64","","Converts the value of `self` to an `f64`.",3,[[["self"]],[["f64"],["option",["f64"]]]]],[8,"FromPrimitive","","A generic trait for converting a number to a value.",null,null],[11,"from_isize","","Convert an `isize` to return an optional value of this…",4,[[["isize"]],["option"]]],[11,"from_i8","","Convert an `i8` to return an optional value of this type.…",4,[[["i8"]],["option"]]],[11,"from_i16","","Convert an `i16` to return an optional value of this type.…",4,[[["i16"]],["option"]]],[11,"from_i32","","Convert an `i32` to return an optional value of this type.…",4,[[["i32"]],["option"]]],[10,"from_i64","","Convert an `i64` to return an optional value of this type.…",4,[[["i64"]],["option"]]],[11,"from_i128","","Convert an `i128` to return an optional value of this…",4,[[["i128"]],["option"]]],[11,"from_usize","","Convert a `usize` to return an optional value of this…",4,[[["usize"]],["option"]]],[11,"from_u8","","Convert an `u8` to return an optional value of this type.…",4,[[["u8"]],["option"]]],[11,"from_u16","","Convert an `u16` to return an optional value of this type.…",4,[[["u16"]],["option"]]],[11,"from_u32","","Convert an `u32` to return an optional value of this type.…",4,[[["u32"]],["option"]]],[10,"from_u64","","Convert an `u64` to return an optional value of this type.…",4,[[["u64"]],["option"]]],[11,"from_u128","","Convert an `u128` to return an optional value of this…",4,[[["u128"]],["option"]]],[11,"from_f32","","Convert a `f32` to return an optional value of this type.…",4,[[["f32"]],["option"]]],[11,"from_f64","","Convert a `f64` to return an optional value of this type.…",4,[[["f64"]],["option"]]],[8,"NumCast","","An interface for casting between machine scalars.",null,null],[10,"from","","Creates a number from another value that can be converted…",5,[[["toprimitive"]],["option"]]],[8,"AsPrimitive","","A generic interface for casting between machine scalars…",null,null],[10,"as_","","Convert a value to another, using the `as` operator.",6,[[],["t"]]],[0,"float","num_traits","",null,null],[8,"FloatCore","num_traits::float","Generic trait for floating point numbers that works with…",null,null],[10,"infinity","","Returns positive infinity.",7,[[],["self"]]],[10,"neg_infinity","","Returns negative infinity.",7,[[],["self"]]],[10,"nan","","Returns NaN.",7,[[],["self"]]],[10,"neg_zero","","Returns `-0.0`.",7,[[],["self"]]],[10,"min_value","","Returns the smallest finite value that this type can…",7,[[],["self"]]],[10,"min_positive_value","","Returns the smallest positive, normalized value that this…",7,[[],["self"]]],[10,"epsilon","","Returns epsilon, a small positive value.",7,[[],["self"]]],[10,"max_value","","Returns the largest finite value that this type can…",7,[[],["self"]]],[11,"is_nan","","Returns `true` if the number is NaN.",7,[[],["bool"]]],[11,"is_infinite","","Returns `true` if the number is infinite.",7,[[],["bool"]]],[11,"is_finite","","Returns `true` if the number is neither infinite or NaN.",7,[[],["bool"]]],[11,"is_normal","","Returns `true` if the number is neither zero, infinite,…",7,[[],["bool"]]],[10,"classify","","Returns the floating point category of the number. If only…",7,[[],["fpcategory"]]],[11,"floor","","Returns the largest integer less than or equal to a number.",7,[[],["self"]]],[11,"ceil","","Returns the smallest integer greater than or equal to a…",7,[[],["self"]]],[11,"round","","Returns the nearest integer to a number. Round half-way…",7,[[],["self"]]],[11,"trunc","","Return the integer part of a number.",7,[[],["self"]]],[11,"fract","","Returns the fractional part of a number.",7,[[],["self"]]],[11,"abs","","Computes the absolute value of `self`. Returns…",7,[[],["self"]]],[11,"signum","","Returns a number that represents the sign of `self`.",7,[[],["self"]]],[11,"is_sign_positive","","Returns `true` if `self` is positive, including `+0.0` and…",7,[[],["bool"]]],[11,"is_sign_negative","","Returns `true` if `self` is negative, including `-0.0` and…",7,[[],["bool"]]],[11,"min","","Returns the minimum of the two numbers.",7,[[],["self"]]],[11,"max","","Returns the maximum of the two numbers.",7,[[],["self"]]],[11,"recip","","Returns the reciprocal (multiplicative inverse) of the…",7,[[],["self"]]],[11,"powi","","Raise a number to an integer power.",7,[[["i32"]],["self"]]],[10,"to_degrees","","Converts to degrees, assuming the number is in radians.",7,[[],["self"]]],[10,"to_radians","","Converts to radians, assuming the number is in degrees.",7,[[],["self"]]],[10,"integer_decode","","Returns the mantissa, base 2 exponent, and sign as…",7,[[]]],[8,"FloatConst","","",null,null],[10,"E","","Return Euler’s number.",8,[[],["self"]]],[10,"FRAC_1_PI","","Return `1.0 / π`.",8,[[],["self"]]],[10,"FRAC_1_SQRT_2","","Return `1.0 / sqrt(2.0)`.",8,[[],["self"]]],[10,"FRAC_2_PI","","Return `2.0 / π`.",8,[[],["self"]]],[10,"FRAC_2_SQRT_PI","","Return `2.0 / sqrt(π)`.",8,[[],["self"]]],[10,"FRAC_PI_2","","Return `π / 2.0`.",8,[[],["self"]]],[10,"FRAC_PI_3","","Return `π / 3.0`.",8,[[],["self"]]],[10,"FRAC_PI_4","","Return `π / 4.0`.",8,[[],["self"]]],[10,"FRAC_PI_6","","Return `π / 6.0`.",8,[[],["self"]]],[10,"FRAC_PI_8","","Return `π / 8.0`.",8,[[],["self"]]],[10,"LN_10","","Return `ln(10.0)`.",8,[[],["self"]]],[10,"LN_2","","Return `ln(2.0)`.",8,[[],["self"]]],[10,"LOG10_E","","Return `log10(e)`.",8,[[],["self"]]],[10,"LOG2_E","","Return `log2(e)`.",8,[[],["self"]]],[10,"PI","","Return Archimedes’ constant.",8,[[],["self"]]],[10,"SQRT_2","","Return `sqrt(2.0)`.",8,[[],["self"]]],[0,"identities","num_traits","",null,null],[5,"zero","num_traits::identities","Returns the additive identity, `0`.",null,[[],["zero"]]],[5,"one","","Returns the multiplicative identity, `1`.",null,[[],["one"]]],[8,"Zero","","Defines an additive identity element for `Self`.",null,null],[10,"zero","","Returns the additive identity element of `Self`, `0`. #…",9,[[],["self"]]],[11,"set_zero","","Sets `self` to the additive identity element of `Self`, `0`.",9,[[["self"]]]],[10,"is_zero","","Returns `true` if `self` is equal to the additive identity.",9,[[["self"]],["bool"]]],[8,"One","","Defines a multiplicative identity element for `Self`.",null,null],[10,"one","","Returns the multiplicative identity element of `Self`, `1`.",10,[[],["self"]]],[11,"set_one","","Sets `self` to the multiplicative identity element of…",10,[[["self"]]]],[11,"is_one","","Returns `true` if `self` is equal to the multiplicative…",10,[[["self"]],["bool"]]],[0,"int","num_traits","",null,null],[8,"PrimInt","num_traits::int","Generic trait for primitive integers.",null,null],[10,"count_ones","","Returns the number of ones in the binary representation of…",11,[[],["u32"]]],[10,"count_zeros","","Returns the number of zeros in the binary representation…",11,[[],["u32"]]],[10,"leading_zeros","","Returns the number of leading zeros in the binary…",11,[[],["u32"]]],[10,"trailing_zeros","","Returns the number of trailing zeros in the binary…",11,[[],["u32"]]],[10,"rotate_left","","Shifts the bits to the left by a specified amount amount,…",11,[[["u32"]],["self"]]],[10,"rotate_right","","Shifts the bits to the right by a specified amount amount,…",11,[[["u32"]],["self"]]],[10,"signed_shl","","Shifts the bits to the left by a specified amount amount,…",11,[[["u32"]],["self"]]],[10,"signed_shr","","Shifts the bits to the right by a specified amount amount,…",11,[[["u32"]],["self"]]],[10,"unsigned_shl","","Shifts the bits to the left by a specified amount amount,…",11,[[["u32"]],["self"]]],[10,"unsigned_shr","","Shifts the bits to the right by a specified amount amount,…",11,[[["u32"]],["self"]]],[10,"swap_bytes","","Reverses the byte order of the integer.",11,[[],["self"]]],[10,"from_be","","Convert an integer from big endian to the target's…",11,[[],["self"]]],[10,"from_le","","Convert an integer from little endian to the target's…",11,[[],["self"]]],[10,"to_be","","Convert `self` to big endian from the target's endianness.",11,[[],["self"]]],[10,"to_le","","Convert `self` to little endian from the target's…",11,[[],["self"]]],[10,"pow","","Raises self to the power of `exp`, using exponentiation by…",11,[[["u32"]],["self"]]],[0,"ops","num_traits","",null,null],[0,"checked","num_traits::ops","",null,null],[8,"CheckedAdd","num_traits::ops::checked","Performs addition that returns `None` instead of wrapping…",null,null],[10,"checked_add","","Adds two numbers, checking for overflow. If overflow…",12,[[["self"]],["option"]]],[8,"CheckedSub","","Performs subtraction that returns `None` instead of…",null,null],[10,"checked_sub","","Subtracts two numbers, checking for underflow. If…",13,[[["self"]],["option"]]],[8,"CheckedMul","","Performs multiplication that returns `None` instead of…",null,null],[10,"checked_mul","","Multiplies two numbers, checking for underflow or…",14,[[["self"]],["option"]]],[8,"CheckedDiv","","Performs division that returns `None` instead of panicking…",null,null],[10,"checked_div","","Divides two numbers, checking for underflow, overflow and…",15,[[["self"]],["option"]]],[8,"CheckedRem","","Performs an integral remainder that returns `None` instead…",null,null],[10,"checked_rem","","Finds the remainder of dividing two numbers, checking for…",16,[[["self"]],["option"]]],[8,"CheckedNeg","","Performs negation that returns `None` if the result can't…",null,null],[10,"checked_neg","","Negates a number, returning `None` for results that can't…",17,[[["self"]],["option"]]],[8,"CheckedShl","","Performs a left shift that returns `None` on shifts larger…",null,null],[10,"checked_shl","","Checked shift left. Computes `self << rhs`, returning…",18,[[["u32"],["self"]],["option"]]],[8,"CheckedShr","","Performs a right shift that returns `None` on shifts…",null,null],[10,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning…",19,[[["u32"],["self"]],["option"]]],[0,"inv","num_traits::ops","",null,null],[8,"Inv","num_traits::ops::inv","Unary operator for retrieving the multiplicative inverse,…",null,null],[16,"Output","","The result after applying the operator.",20,null],[10,"inv","","Returns the multiplicative inverse of `self`.",20,[[]]],[0,"mul_add","num_traits::ops","",null,null],[8,"MulAdd","num_traits::ops::mul_add","Fused multiply-add. Computes `(self * a) + b` with only…",null,null],[16,"Output","","The resulting type after applying the fused multiply-add.",21,null],[10,"mul_add","","Performs the fused multiply-add operation.",21,[[["a"],["b"]]]],[8,"MulAddAssign","","The fused multiply-add assignment operation.",null,null],[10,"mul_add_assign","","Performs the fused multiply-add operation.",22,[[["a"],["self"],["b"]]]],[0,"saturating","num_traits::ops","",null,null],[8,"Saturating","num_traits::ops::saturating","Saturating math operations",null,null],[10,"saturating_add","","Saturating addition operator. Returns a+b, saturating at…",23,[[],["self"]]],[10,"saturating_sub","","Saturating subtraction operator. Returns a-b, saturating…",23,[[],["self"]]],[0,"wrapping","num_traits::ops","",null,null],[8,"WrappingAdd","num_traits::ops::wrapping","Performs addition that wraps around on overflow.",null,null],[10,"wrapping_add","","Wrapping (modular) addition. Computes `self + other`,…",24,[[["self"]],["self"]]],[8,"WrappingSub","","Performs subtraction that wraps around on overflow.",null,null],[10,"wrapping_sub","","Wrapping (modular) subtraction. Computes `self - other`,…",25,[[["self"]],["self"]]],[8,"WrappingMul","","Performs multiplication that wraps around on overflow.",null,null],[10,"wrapping_mul","","Wrapping (modular) multiplication. Computes `self *…",26,[[["self"]],["self"]]],[8,"WrappingShl","","Performs a left shift that does not panic.",null,null],[10,"wrapping_shl","","Panic-free bitwise shift-left; yields `self << mask(rhs)`,…",27,[[["u32"],["self"]],["self"]]],[8,"WrappingShr","","Performs a right shift that does not panic.",null,null],[10,"wrapping_shr","","Panic-free bitwise shift-right; yields `self >>…",28,[[["u32"],["self"]],["self"]]],[0,"pow","num_traits","",null,null],[5,"pow","num_traits::pow","Raises a value to the power of exp, using exponentiation…",null,[[["usize"],["clone"],["mul"],["one"]],[["clone"],["mul"],["one"]]]],[5,"checked_pow","","Raises a value to the power of exp, returning `None` if an…",null,[[["checkedmul"],["usize"],["clone"],["one"]],[["one"],["option"],["clone"],["checkedmul"]]]],[8,"Pow","","Binary operator for raising a value to a power.",null,null],[16,"Output","","The result after applying the operator.",29,null],[10,"pow","","Returns `self` to the power `rhs`.",29,[[["rhs"]]]],[0,"sign","num_traits","",null,null],[5,"abs","num_traits::sign","Computes the absolute value.",null,[[["signed"]],["signed"]]],[5,"abs_sub","","The positive difference of two numbers.",null,[[["signed"]],["signed"]]],[5,"signum","","Returns the sign of the number.",null,[[["signed"]],["signed"]]],[8,"Signed","","Useful functions for signed numbers (i.e. numbers that can…",null,null],[10,"abs","","Computes the absolute value.",30,[[["self"]],["self"]]],[10,"abs_sub","","The positive difference of two numbers.",30,[[["self"]],["self"]]],[10,"signum","","Returns the sign of the number.",30,[[["self"]],["self"]]],[10,"is_positive","","Returns true if the number is positive and false if the…",30,[[["self"]],["bool"]]],[10,"is_negative","","Returns true if the number is negative and false if the…",30,[[["self"]],["bool"]]],[8,"Unsigned","","A trait for values which cannot be negative",null,null],[8,"Num","num_traits","The base trait for numeric types, covering `0` and `1`…",null,null],[16,"FromStrRadixErr","","",31,null],[10,"from_str_radix","","Convert from a string and radix <= 36.",31,[[["str"],["u32"]],["result"]]],[8,"NumOps","","The trait for types implementing basic numeric operations",null,null],[8,"NumRef","","The trait for `Num` types which also implement numeric…",null,null],[8,"RefNum","","The trait for references which implement numeric…",null,null],[8,"NumAssignOps","","The trait for types implementing numeric assignment…",null,null],[8,"NumAssign","","The trait for `Num` types which also implement assignment…",null,null],[8,"NumAssignRef","","The trait for `NumAssign` types which also implement…",null,null],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"into","","",0,[[],["u"]]],[11,"try_into","","",0,[[],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"type_id","","",0,[[["self"]],["typeid"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"into","","",1,[[],["u"]]],[11,"try_into","","",1,[[],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"type_id","","",1,[[["self"]],["typeid"]]],[11,"fmt","","",1,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",0,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]]],"p":[[3,"ParseFloatError"],[4,"FloatErrorKind"],[8,"Bounded"],[8,"ToPrimitive"],[8,"FromPrimitive"],[8,"NumCast"],[8,"AsPrimitive"],[8,"FloatCore"],[8,"FloatConst"],[8,"Zero"],[8,"One"],[8,"PrimInt"],[8,"CheckedAdd"],[8,"CheckedSub"],[8,"CheckedMul"],[8,"CheckedDiv"],[8,"CheckedRem"],[8,"CheckedNeg"],[8,"CheckedShl"],[8,"CheckedShr"],[8,"Inv"],[8,"MulAdd"],[8,"MulAddAssign"],[8,"Saturating"],[8,"WrappingAdd"],[8,"WrappingSub"],[8,"WrappingMul"],[8,"WrappingShl"],[8,"WrappingShr"],[8,"Pow"],[8,"Signed"],[8,"Num"]]};
addSearchOptions(searchIndex);initSearch(searchIndex);